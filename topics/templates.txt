================================
Le langage de template de Django
================================

.. admonition:: A propos de ce document

    Ce document explique la syntaxe du langage de système de mise en page de Django. Si
    vous recherchez une approche plus technique sur son fonctionnement et sur son extension,
    voyez :doc:`/ref/templates/api`.

Le langage de mise en page de Django est conçu pour allier puissance et facilité d'utilisation. Il est conçu pour que les personnes habituées à travailler avec le HTML se sentent à l'aise. Si vous avez déjà utilisé d'autres langages de mise en page, comme Smarty_
ou CheetahTemplate_, vous devriez vous sentir comme à la maison avec les templates Django.

.. admonition:: Philosophie

    Si vous avez une formation en programmation, ou si vous êtes habitué à des 
    lagages comme PHP qui mélangent directement du code-source à du HTML, vous
    devez garder à l'esprit que le système de mise en page de Django n'est pas
    simplement du Python incorporé à du HTML. C'est intentionnel : le système 
    de template est destiné à exprimer la présentation, pas la logique du programme.

    Le système de template de Django fournit des balises (*tags*) quifonctionnent
    de manière similaire à certaines constructions de programmation -- une balise 
    :ttag:`if` pour les tests booléens, une balise :ttag:`for` pour les boucles, etc.
    -- mais ils ne sont pas simplement exécutés comme le code Python correspondant, 
    et le système de template n'exécutera pas des expressions Python arbitraires. 
    Seuls les balises, les filtres et la syntaxe énumérés ci-dessous sont prises 
    en charge par défaut (bien que vous puissiez ajouter :doc:`your own extensions
    </howto/custom-template-tags>` au langage de template si nécessaire).

.. _`The Django template language: For Python programmers`: ../templates_python/
.. _Smarty: http://smarty.php.net/
.. _CheetahTemplate: http://www.cheetahtemplate.org/

Templates (maquettes, gabarits de mise en page)
===============================================

.. highlightlang:: html+django

Un template est simplement un fichier texte. Il peut produire n'importe quel format de texte (HTML,
XML, CSV, etc.).

Un template contient des **variables**, qui sont remplacées par des valeurs lorsque le template est évalué, et des **tags** (balises), qui contrôlent la logique de la mise en page.

Voici une mise en page minimaliste qui illustre quelques notions de base. Chaque élément sera expliqué plus loin dans ce document.::

    {% extends "base_generic.html" %}

    {% block title %}{{ section.title }}{% endblock %}

    {% block content %}
    <h1>{{ section.title }}</h1>

    {% for story in story_list %}
    <h2>
      <a href="{{ story.get_absolute_url }}">
        {{ story.headline|upper }}
      </a>
    </h2>
    <p>{{ story.tease|truncatewords:"100" }}</p>
    {% endfor %}
    {% endblock %}

.. admonition:: Philosophie

    Pourquoi utiliser une mise en page à base texte au lieu d'un mise en page à base d'XML (comme TAL de Zope)? Nous voulions que le langage de mise en page de Django soit utilisable pour quelque chose de plus que des maquettes XML/HTML. À World Online, nous l'utilisons pour les e-mails, JavaScript et CSV. Vous pouvez utiliser le langage de template pour n'importe quel format basé sur du texte.

    Oh, il y a aussi cela : demander à des humains qu'ils éditent du XML est sadique !

Variables
=========

Les variables ressemble à ça: ``{{ variable }}``. Lorsque le moteur de template rencontre une variable, il l'évalue et la remplace par le résultat de cette évaluation. Les noms de variables consistent en une combinaison de caractères alphanumériques et de l'underscore (``"_"``). Le point (``"."``) apparaît également dans les variables, bien qu'il ait une signification spéciale, comme nous le verrons plus tard.
**Important**, *vous ne pouvez pas avoir d'espaces ou des caractères de ponctuation dans les noms de variables.*

Utilisez un point (``.``) pour accèder aux attributs d'une variable.

.. admonition:: En coulisses

    Techniquement, lorsque le système de template trouve un point, il essaie les recherches suivantes, dans cet ordre:

    * Recherche dans le dictionnaire
    * Recherche dans les attributs
    * Appel de méthode
    * Recherche List-index lookup
    
    Cela peut causer des comportement innatendus avec les objets qui surchargent les recherches Dictionnaire. 
    Par exemple, voyons le code suivant qui essaie de boucler sur un ``collections.defaultdict``::

      {% for k, v in defaultdict.iteritems %}
         Ici, faire quelque chose avec k et v...
      {% endfor %}

    Comme les recherches Dictionnaire ont lieu en premier, ce comportement se plante et fournit une valeur par défaut au lieu de la méthode ``iteritems()`` attendue. Dans ce cas, pensez à convertir d'abord en un dictionnaire.
	

Dans l'exemple précédent, ``{{ section.title }}`` sera remplacé par l'attribut ``title`` de l'objet ``section``.

Si vous utilisez une variable qui n'existe pas, le système de template insérera la valeur du paramètre :setting:`TEMPLATE_STRING_IF_INVALID`, qui est initialisé à ``''`` (chaîne vide) par défaut.

Filtres
=======

Vous pouvez modifier les variables à afficher en utilisant des **filtres**.

Les filtres ressemblent à ça : ``{{ name|lower }}``. Cela affiche la valeur de la variable 
``{{ name }}`` après filtrage via le filtre :tfilter:`lower`, qui convertit le texte en minuscules. Utilisez un pipe (``|``) pour appliquer un filtre.

les filtres peuvent être "enchaînés". La sortie d'un filtre est appliqué au suivant.
``{{ text|escape|linebreaks }}`` est une tournure habituelle pour échapper des contenus texte, puis pour convertir les fins de ligne en balises ``<p>``.

Certains filtres prennent des arguments. Un argument de filtre ressemble à ça: ``{{bio|truncatewords:30 }}``. Cela affiche les 30 premiers mots de la variable ``bio``.

Les arguments de filtre qui contiennent des espaces doivent être mis entre guillemets; par exemple, pour lier une liste avec des virgules et des espaces vous utiliserez ``{{ list|join:", " }}``.

Django fournit environ une trentaine de filtres de mise en page intégrés. Vous lirez tout à leur sujet dans :ref:`built-in filter reference <ref-templates-builtins-filters>`.

Pour vous donner un parfum de ce qui est disponible, en voici quelques uns, parmi ceux les plus utilisés:

:tfilter:`default`
    Si une variable est fausse ou vide, utiliser la valeur par défaut indiquée. Sinon, utiliser la valeur de la variable.

    Par exemple::

        {{ value|default:"rien" }}

    Si ``value`` n'est pas fourni ou vide, ce qui précède affichera 
    "``rien``".

:tfilter:`length`
    Renvoie la longueur de la valeur. Cela marche avec les chaînes et les listes;
    par exemple::

        {{ value|length }}

    Si ``value`` est ``['a', 'b', 'c', 'd']``, la sortie sera ``4``.

:tfilter:`striptags`
    Enlève toutes les balises [X]HTML. Par exemple::

        {{ value|striptags }}

    Si ``value`` est ``"<b>Joel</b> <button>is</button> a
    <span>slug</span>"``, la sortie sera ``"Joel is a slug"``.

À nouveau, ce ne sont que quelques exemples; voir  :ref:`built-in filter reference
<ref-templates-builtins-filters>` pour la liste complète.

Vous pouvez aussi créer vos propres filtres de mise en page personnalisées; voir :doc:`/howto/custom-template-tags`.

.. seealso::

    L'interface administration de Django peut inclure une référence complète de toutes les balises de mise en page et des filtres d'un sitge donné. Voir :doc:`/ref/contrib/admin/admindocs`.

Balises (Tags)
==============

Les balises ressemblent à ça : ``{% tag %}``. Les balises sont plus complexes que les variables : certaines créent du texte dans la sortie, d'autres contrôlent les flux en exécutant des boucles ou des tests booléens, et d'autres encore chargent des données externes dans le template pour qu'elles soient utilisées plus tard par des variables.

Certaines balises requièrent un marquage de début et de fin (c'est à dire ``{% tag %} ... tag contents
... {% endtag %}``).

Django est livré avec environ deux douzaines de balises intégrées. Vous pouvez tout lire à leur sujet dans :ref:`built-in tag reference <ref-templates-builtins-tags>`. Pour vous donner un parfum de ce qui est disponible, en voici quelques unes, parmi celles les plus utilisées:

:ttag:`for`
    Boucle sur chaque élément d'un tableau. Par exemple, pour afficher une liste des athlètes fournis dans ``athlete_list``::

        <ul>
        {% for athlete in athlete_list %}
            <li>{{ athlete.name }}</li>
        {% endfor %}
        </ul>

:ttag:`if` and ``else``
    Évalue une variable, et si elle est "true" le contenu du bloc sera affiché::

        {% if athlete_list %}
            Number of athletes: {{ athlete_list|length }}
        {% else %}
            No athletes.
        {% endif %}

    Dans ce code, si ``athlete_list`` n'est pas vide, le nombre d'athlètes sera affiché par la variable ``{{ athlete_list|length }}``.

    Vous pouvez aussi utiliser des filtres et différents opérateurs dans la balise :ttag:`if`::

        {% if athlete_list|length > 1 %}
           Équipe: {% for athlete in athlete_list %} ... {% endfor %}
        {% else %}
           Athlète: {{ athlete_list.0.name }}
        {% endif %}

:ttag:`block` and :ttag:`extends`
    Paramètre l'`Héritage de mise en page`_ (voir ci-dessous), un puissant moyen pour réduire le texte passe-partout dans les mises en page.

À nouveau ce qui précède n'est qu'une petite sélection; voir :ref:`built-in tag reference <ref-templates-builtins-tags>` pour la liste complète.

Vous pouvez aussi créer vos propres balises de mise en page personnalisées; voir :doc:`/howto/custom-template-tags`.

.. seealso::

    L'interface administration de Django peut inclure une référence complète de toutes les balises de mise en page et des filtres d'un sitge donné. Voir :doc:`/ref/contrib/admin/admindocs`.


Commentaires
============

Pour mettre une ligne du template en commentaire, utilisez la syntaxe: ``{# #}``.

Par exemple, cette mise en page produira ``'hello'``::

    {# greeting #}hello

Un commentaire peut contenir n'importe quel code de template, valide ou pas. Par exemple ::

    {# {% if foo %}bar{% else %} #}

Cette syntaxe ne peut être utilisée que pour des commentaires tenant sur une seule ligne (pas de retour à la ligne d'autorisé entre les délimiteurs ``{#`` et ``#}`` ). Si vous avez besoin de mettre en commentaire plusieurs lignes du template, voir la balise :ttag:`comment`.

.. _template-inheritance:

Héritage de mise en page
========================

La partie la plus puissante -- et aussi la plus complexe -- du moteur de template de Django est l'héritage de template. L'héritage de mise en page vous permet de construire un squelette de "base" qui contient tous les élements communs de votre site et qui définit des **blocs** que les mises en page *enfant* pourront surcharger.

L'héritage de mise en page est plus simple à comprendre avec un exemple::

    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <link rel="stylesheet" href="style.css" />
        <title>{% block title %}My amazing site{% endblock %}</title>
    </head>

    <body>
        <div id="sidebar">
            {% block sidebar %}
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/blog/">Blog</a></li>
            </ul>
            {% endblock %}
        </div>

        <div id="content">
            {% block content %}{% endblock %}
        </div>
    </body>
    </html>

Cette mise en page, que nous appelerons ``base.html``, définit un simple squelette HTML qui pourra être utilisé pour une mise en page sur deux colonnes. Le boulot qui consiste à remplir les blocs vides avec du contenu appartient aux templates "enfants".

Dans cet exemple, la balise :ttag:`block` déclare trois blocs que les templates enfants pourront remplir. Tout ce que fait la balise :ttag:`block` est de dire au moteur de template qu'un template enfant peut surcharger ces parties du template.

Un template enfant peut ressembler à ceci::

    {% extends "base.html" %}

    {% block title %}My amazing blog{% endblock %}

    {% block content %}
    {% for entry in blog_entries %}
        <h2>{{ entry.title }}</h2>
        <p>{{ entry.body }}</p>
    {% endfor %}
    {% endblock %}

Ici, la clé est la balise :ttag:`extends`. Elle dit au moteur de template que ce template en "étend" un autre. Lorsque le système de template évalue ce template-ci, il localise d'abord le parent -- c'est à dire : "base.html" dans le cas présent.

À ce stade, le moteur de template repérera les trois balises :ttag:`block` de ``base.html`` et remplacera ces blocs par le contenu du template enfant. Selon la valeur de ``blog_entries``, la sortie ressemblera à ::

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <link rel="stylesheet" href="style.css" />
        <title>My amazing blog</title>
    </head>

    <body>
        <div id="sidebar">
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/blog/">Blog</a></li>
            </ul>
        </div>

        <div id="content">
            <h2>Entry one</h2>
            <p>This is my first entry.</p>

            <h2>Entry two</h2>
            <p>This is my second entry.</p>
        </div>
    </body>
    </html>

Notez que puisque le template enfant ne définit pas le bloc ``sidebar``, la valeur du template parent sera utilisée. Le contenu d'une balise ``{% block %}`` d'un template parent est toujours utilisée en dernier recours.

Vous pouvez utiliser autant de niveaux d'héritage que vous le souhaitez. Une façon habituelle de procéder est l'approche trois-niveaux suivante:

* Créez un template ``base.html`` qui détiendra le look-and-feel principal de votre site.
* Créez un template ``base_SECTIONNAME.html`` pour chaque "section" de votre site.
  Par exemple, ``base_news.html``, ``base_sports.html``. Ces templates étendent tous 
  ``base.html`` et contiennent les styles et design spécifiques à la section.
* Créez des templates individuels pour chaque type de page, comme un article d'actualité ou une entrée de blog. Ces templates étendront la section adéquate du template.

Cette approche maximize la réutilisation du code et facilite l'ajout d'élèments dans les sections partagées, comme une section de navigation.

Voici quelques astuces pour travailler avec l'héritage:

* Si vous utilisez :ttag:`{% extends %}<extends>` dans un template, ce doit être la première balise du template. Sinon l'héritage ne marchera pas.

* Davantage de balises :ttag:`{% block %}<block>` dans votre templates de base est mieux. Rappelez-vous,
  les templates enfants n'ont pas à définir tous les blocs parents, vous pouvez donc renseigner raisonnablement des valeurs par défaut dans différents blocs, puis ne définir que ceux dont vous aurez besoin plus tard. Il vaut mieux avoir davantage de hooks que pas assez.

* Si vous vous retrouvez à dupliquer du contenu dans différents templates, cela veut probablement dire que vous devriez déplacer ce contenu vers un ``{% block %}`` du template parent.

* Si vous avez besoin du contenu d'un bloc du template parent, la variable ``{{ block.super }}`` vous le fournira. 
  C'est utile si vous voulez ajouter du contenu à celui du bloc parent au lieu de le remplacer complètement. Les données insérées en utilisant``{{ block.super }}`` ne seront pas échapées automatiquement (voir `section suivante`_), puisqu'elles auront déjà été échappées, si besoin, dans le template parent.

* Pour une meilleure lisibilité, vous pouvez donner un *nom* à votre balise ``{% endblock %}``. Par exemple::

      {% block content %}
      ...
      {% endblock content %}

  Dans les grands templates, cette technique vous aide à voir quelles balises ``{% block %}`` sont fermées.

Pour finir, sachez que vous ne pouvez pas déclarer plusieurs balises :ttag:`block` avec le même nom dans le même template. Cette limitation éxiste parce qu'une blaise bloc fonctionne dans "les deux" sens. C'est à dire qu'une balise de bloc ne fournit pas seulement un emplacement à remplir -- elle déclare aussi le contenu qui remplit l'emplacement *dans* le parent. S'il y avait deux balises de :ttag:`block` avec le même nom dans un template, ce template parent ne saurait pas quelcontenu de bloc utiliser.

.. _section suivante: #automatic-html-escaping
.. _automatic-html-escaping:

Échappement HTML automatique
============================

Lorsque l'on génère du HTML à partir des templates, il y a toujours le risque qu'une variable comporte des caractères qui affecteraient le code HTML résultant. Par exemple, étudions ce morceau de template::

    Hello, {{ name }}.

At first, this seems like a harmless way to display a user's name, but consider
what would happen if the user entered his name as this::

    <script>alert('hello')</script>

With this name value, the template would be rendered as::

    Hello, <script>alert('hello')</script>

...which means the browser would pop-up a JavaScript alert box!

Similarly, what if the name contained a ``'<'`` symbol, like this?

.. code-block:: html

    <b>username

That would result in a rendered template like this::

    Hello, <b>username

...which, in turn, would result in the remainder of the Web page being bolded!

Clearly, user-submitted data shouldn't be trusted blindly and inserted directly
into your Web pages, because a malicious user could use this kind of hole to
do potentially bad things. This type of security exploit is called a
`Cross Site Scripting`_ (XSS) attack.

To avoid this problem, you have two options:

* One, you can make sure to run each untrusted variable through the
  :tfilter:`escape` filter (documented below), which converts potentially
  harmful HTML characters to unharmful ones. This was the default solution
  in Django for its first few years, but the problem is that it puts the
  onus on *you*, the developer / template author, to ensure you're escaping
  everything. It's easy to forget to escape data.

* Two, you can take advantage of Django's automatic HTML escaping. The
  remainder of this section describes how auto-escaping works.

By default in Django, every template automatically escapes the output
of every variable tag. Specifically, these five characters are
escaped:

* ``<`` is converted to ``&lt;``
* ``>`` is converted to ``&gt;``
* ``'`` (single quote) is converted to ``&#39;``
* ``"`` (double quote) is converted to ``&quot;``
* ``&`` is converted to ``&amp;``

Again, we stress that this behavior is on by default. If you're using Django's
template system, you're protected.

.. _Cross Site Scripting: http://en.wikipedia.org/wiki/Cross-site_scripting

How to turn it off
------------------

If you don't want data to be auto-escaped, on a per-site, per-template level or
per-variable level, you can turn it off in several ways.

Why would you want to turn it off? Because sometimes, template variables
contain data that you *intend* to be rendered as raw HTML, in which case you
don't want their contents to be escaped. For example, you might store a blob of
HTML in your database and want to embed that directly into your template. Or,
you might be using Django's template system to produce text that is *not* HTML
-- like an email message, for instance.

For individual variables
~~~~~~~~~~~~~~~~~~~~~~~~

To disable auto-escaping for an individual variable, use the :tfilter:`safe`
filter::

    This will be escaped: {{ data }}
    This will not be escaped: {{ data|safe }}

Think of *safe* as shorthand for *safe from further escaping* or *can be
safely interpreted as HTML*. In this example, if ``data`` contains ``'<b>'``,
the output will be::

    This will be escaped: &lt;b&gt;
    This will not be escaped: <b>

For template blocks
~~~~~~~~~~~~~~~~~~~

To control auto-escaping for a template, wrap the template (or just a
particular section of the template) in the :ttag:`autoescape` tag, like so::

    {% autoescape off %}
        Hello {{ name }}
    {% endautoescape %}

The :ttag:`autoescape` tag takes either ``on`` or ``off`` as its argument. At
times, you might want to force auto-escaping when it would otherwise be
disabled. Here is an example template::

    Auto-escaping is on by default. Hello {{ name }}

    {% autoescape off %}
        This will not be auto-escaped: {{ data }}.

        Nor this: {{ other_data }}
        {% autoescape on %}
            Auto-escaping applies again: {{ name }}
        {% endautoescape %}
    {% endautoescape %}

The auto-escaping tag passes its effect onto templates that extend the
current one as well as templates included via the :ttag:`include` tag,
just like all block tags. For example::

    # base.html

    {% autoescape off %}
    <h1>{% block title %}{% endblock %}</h1>
    {% block content %}
    {% endblock %}
    {% endautoescape %}


    # child.html

    {% extends "base.html" %}
    {% block title %}This & that{% endblock %}
    {% block content %}{{ greeting }}{% endblock %}

Because auto-escaping is turned off in the base template, it will also be
turned off in the child template, resulting in the following rendered
HTML when the ``greeting`` variable contains the string ``<b>Hello!</b>``::

    <h1>This & that</h1>
    <b>Hello!</b>

Notes
-----

Generally, template authors don't need to worry about auto-escaping very much.
Developers on the Python side (people writing views and custom filters) need to
think about the cases in which data shouldn't be escaped, and mark data
appropriately, so things Just Work in the template.

If you're creating a template that might be used in situations where you're
not sure whether auto-escaping is enabled, then add an :tfilter:`escape` filter
to any variable that needs escaping. When auto-escaping is on, there's no
danger of the :tfilter:`escape` filter *double-escaping* data -- the
:tfilter:`escape` filter does not affect auto-escaped variables.

.. _string-literals-and-automatic-escaping:

String literals and automatic escaping
--------------------------------------

As we mentioned earlier, filter arguments can be strings::

    {{ data|default:"This is a string literal." }}

All string literals are inserted **without** any automatic escaping into the
template -- they act as if they were all passed through the :tfilter:`safe`
filter. The reasoning behind this is that the template author is in control of
what goes into the string literal, so they can make sure the text is correctly
escaped when the template is written.

This means you would write ::

    {{ data|default:"3 &lt; 2" }}

...rather than ::

    {{ data|default:"3 < 2" }}  <-- Bad! Don't do this.

This doesn't affect what happens to data coming from the variable itself.
The variable's contents are still automatically escaped, if necessary, because
they're beyond the control of the template author.

.. _template-accessing-methods:

Accessing method calls
======================

Most method calls attached to objects are also available from within templates.
This means that templates have access to much more than just class attributes
(like field names) and variables passed in from views. For example, the Django
ORM provides the :ref:`"entry_set"<topics-db-queries-related>` syntax for
finding a collection of objects related on a foreign key. Therefore, given
a model called "comment" with a foreign key relationship to a model called
"task" you can loop through all comments attached to a given task like this::

    {% for comment in task.comment_set.all %}
        {{ comment }}
    {% endfor %}

Similarly, :doc:`QuerySets</ref/models/querysets>` provide a ``count()`` method
to count the number of objects they contain. Therefore, you can obtain a count
of all comments related to the current task with::

    {{ task.comment_set.all.count }}

And of course you can easily access methods you've explicitly defined on your
own models::

    # In model
    class Task(models.Model):
        def foo(self):
            return "bar"

    # In template
    {{ task.foo }}

Because Django intentionally limits the amount of logic processing available
in the template language, it is not possible to pass arguments to method calls
accessed from within templates. Data should be calculated in views, then passed
to templates for display.

.. _loading-custom-template-libraries:

Custom tag and filter libraries
===============================

Certain applications provide custom tag and filter libraries. To access them in
a template, use the :ttag:`load` tag::

    {% load comments %}

    {% comment_form for blogs.entries entry.id with is_public yes %}

In the above, the :ttag:`load` tag loads the ``comments`` tag library, which then
makes the ``comment_form`` tag available for use. Consult the documentation
area in your admin to find the list of custom libraries in your installation.

The :ttag:`load` tag can take multiple library names, separated by spaces.
Example::

    {% load comments i18n %}

See :doc:`/howto/custom-template-tags` for information on writing your own custom
template libraries.

Custom libraries and template inheritance
-----------------------------------------

When you load a custom tag or filter library, the tags/filters are only made
available to the current template -- not any parent or child templates along
the template-inheritance path.

For example, if a template ``foo.html`` has ``{% load comments %}``, a child
template (e.g., one that has ``{% extends "foo.html" %}``) will *not* have
access to the comments template tags and filters. The child template is
responsible for its own ``{% load comments %}``.

This is a feature for the sake of maintainability and sanity.
