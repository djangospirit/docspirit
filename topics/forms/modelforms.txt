==========================================
Créer des formulaires à partir des modèles
==========================================

.. module:: django.forms.models
   :synopsis: ModelForm and ModelFormset.

.. currentmodule:: django.forms

``ModelForm``
=============
.. class:: ModelForm

Si vous construisez une application orientée base de données, il y a des chances pour que vos formulaires correspondent étroitement à vos modèles Django. Par exemple, vous pouvez avoir un modèle ``BlogComment``, et vous voudrez créer un formulaire qui permette aux internautes de laisser des commentaires. Dans ce cas, il serait redondant de définir les champs de votre formulaire, puisque vous les avez déjà définis dans votre modèle.

Pour cette raison, Django fournit une classe qui vous permet de créer une classe ``Form`` à partir d'un modèle Django.

Par exemple::

    >>> from django.forms import ModelForm

    # Créer la classe form.
    >>> class ArticleForm(ModelForm):
    ...     class Meta:
    ...         model = Article

    # Créer un formulaire pour ajouter un article.
    >>> form = ArticleForm()

    # Créer un formulaire pour modifier un article existant.
    >>> article = Article.objects.get(pk=1)
    >>> form = ArticleForm(instance=article)

Types de champs
---------------

La classé ``Form`` générée aura un champ de formulaire pour chaque champ du modèle. Chaque champ de modèle a son champ de formulaire correspondant. Par exemple, un ``CharField`` dans un modèle est représenté par un ``CharField`` dans le formulaire. Un champ ``ManyToManyField`` d'un modèle est représenté par un ``MultipleChoiceField``. Voici la liste complète des conversions:

===============================  ========================================
Champ de Modèle                  Champ de formulaire
===============================  ========================================
``AutoField``                    Non représenté dans le formulaire

``BigIntegerField``              ``IntegerField`` avec ``min_value`` 
                                 paramétré à -9223372036854775808 
                                 et ``max_value`` paramétré à
                                 9223372036854775807.

``BooleanField``                 ``BooleanField``

``CharField``                    ``CharField`` avec ``max_length``
                                 paramétré sur le champ de modèle
                                 ``max_length``

``CommaSeparatedIntegerField``   ``CharField``

``DateField``                    ``DateField``

``DateTimeField``                ``DateTimeField``

``DecimalField``                 ``DecimalField``

``EmailField``                   ``EmailField``

``FileField``                    ``FileField``

``FilePathField``                ``CharField``

``FloatField``                   ``FloatField``

``ForeignKey``                   ``ModelChoiceField`` (voir ci-dessous)

``ImageField``                   ``ImageField``

``IntegerField``                 ``IntegerField``

``IPAddressField``               ``IPAddressField``

``GenericIPAddressField``        ``GenericIPAddressField``

``ManyToManyField``              ``ModelMultipleChoiceField`` (voir 
                                 ci-dessous)

``NullBooleanField``             ``CharField``

``PhoneNumberField``             ``USPhoneNumberField``
                                 (de ``django.contrib.localflavor.us``)

``PositiveIntegerField``         ``IntegerField``

``PositiveSmallIntegerField``    ``IntegerField``

``SlugField``                    ``SlugField``

``SmallIntegerField``            ``IntegerField``

``TextField``                    ``CharField`` avec
                                 ``widget=forms.Textarea``

``TimeField``                    ``TimeField``

``URLField``                     ``URLField`` avec ``verify_exists`` 
                                 paramétré sur le champ de modèle
                                 ``verify_exists``
===============================  ========================================

.. versionadded:: 1.2
    ``BigIntegerField`` est nouveau dans Django 1.2.


Comme vous pouvez vous y attendre, les types de champs de modèle ``ForeignKey`` et ``ManyToManyField`` sont des cas particuliers:

* ``ForeignKey`` est représenté par ``django.forms.ModelChoiceField``,
  qui est un ``ChoiceField`` dont les choix sont un modèle ``QuerySet``.

* ``ManyToManyField`` est représenté par 
  ``django.forms.ModelMultipleChoiceField``, qui est un
  ``MultipleChoiceField`` dont les choix sont un modèle ``QuerySet``.

De plus, chaque champ de formulaire généré a des attributs paramétrés comme suit:

* Si le champ du modèle a ``blank=True``, alors le ``required`` du champ de formulaire est paramétré sur
  ``False``. Sinon, ``required=True``.

* Le champ de formulaire ``label`` est paramétré sur le ``verbose_name`` du champ du modèle, avec le premier caractère en majuscule.

* Le champ de formulaire ``help_text`` est paramétré sur le ``help_text`` du champ du modèle.

* Si le champ du modèle a ``choices`` paramétré, le ``widget`` du champ du formulaire
  sera paramétré sur ``Select``, avec les choices fournis par le champ de modèle 
  ``choices``. Les choix comporteront normalement un choix vierge sélectionné par défaut. 
  Si le champ est requis, cela oblige l'utilisateur à faire une sélection.
  Le choix vierge ne sera pas inclus si le champ de modèle a 
  ``blank=False`` et une valeur ``default`` explicite (à la place, la valeur 
  ``default`` sera initialement sélectionnée).

Enfin, notez que vous pouvez surcharger le champ de formulaire d'un champ de modèle donné. Voir `Overriding the default field types or widgets`_ ci-dessous.

Un exemple complet
------------------

Etudions ces modèles::

    from django.db import models
    from django.forms import ModelForm

    TITLE_CHOICES = (
        ('MR', 'Mr.'),
        ('MRS', 'Mrs.'),
        ('MS', 'Ms.'),
    )

    class Author(models.Model):
        name = models.CharField(max_length=100)
        title = models.CharField(max_length=3, choices=TITLE_CHOICES)
        birth_date = models.DateField(blank=True, null=True)

        def __unicode__(self):
            return self.name

    class Book(models.Model):
        name = models.CharField(max_length=100)
        authors = models.ManyToManyField(Author)

    class AuthorForm(ModelForm):
        class Meta:
            model = Author

    class BookForm(ModelForm):
        class Meta:
            model = Book

Avec ces modèles, la sous-classe ``ModelForm`` sera grosso modo équivalente à ceci (la seule différence étant la méthode ``save()``, dont nous parlerons plus tard)::

    from django import forms

    class AuthorForm(forms.Form):
        name = forms.CharField(max_length=100)
        title = forms.CharField(max_length=3,
                    widget=forms.Select(choices=TITLE_CHOICES))
        birth_date = forms.DateField(required=False)

    class BookForm(forms.Form):
        name = forms.CharField(max_length=100)
        authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())

La méthode ``is_valid()`` et les ``errors``
-------------------------------------------

La première fois que vous appelez ``is_valid()`` ou accèdez à l'attribut ``errors`` d'un 
``ModelForm`` cela déclenche la validation du formulaire  validation tout comme celle du modèle :ref:`model validation
<validating-objects>`. Ce qui a comme effet de bord de nettoyer le modèle passé au constructeur ``ModelForm``. Par exemple, appeler ``is_valid()`` sur votre formulaire convertira tout champ date de votre modèle en objets Date réels.


La méthode ``save()`` 
---------------------

Chaque formulaire produit par ``ModelForm`` a aussi une méthode ``save()``. Cette méthodé crée et sauvegarde un objet base de données avec les données liées au formulaire. Une sous-classe de ``ModelForm`` peut prendre une instance de modèle existante en tant qu'argument mot-clé ``instance``; s'il est fourni, ``save()`` sauvegardera cette instance. S'il ne l'est pas ,
``save()`` créera une nouvelle instance du modèle spécifique::

    # Create a form instance from POST data.
    >>> f = ArticleForm(request.POST)

    # Save a new Article object from the form's data.
    >>> new_article = f.save()

    # Create a form to edit an existing Article.
    >>> a = Article.objects.get(pk=1)
    >>> f = ArticleForm(instance=a)
    >>> f.save()

    # Create a form to edit an existing Article, but use
    # POST data to populate the form.
    >>> a = Article.objects.get(pk=1)
    >>> f = ArticleForm(request.POST, instance=a)
    >>> f.save()

Notez que ``save()`` lèvera un ``ValueError`` si les données du formulaire ne valident pas -- par exemple, si form.errors évalue à True.

Cette méthode ``save()`` accepte un argument mot-clé ``commit`` facultatif , qui prend
soit ``True`` soit ``False``. Si vous appelez ``save()`` avec
``commit=False``, elle renverra un objet qui n'aura pas encore été sauvegardé dans la base de données.
Il vous appartient dans ce cas d'appeler le ``save()`` de l'instance de modèle résultante.
C'est utile si vous voulez appliquer un traitement personnalisé sur l'objet avant de le sauvegarder, ou si vous voulez utiliser l'une 
:ref:`options de sauvegarde de modèle <ref-models-force-insert>` spécialisée. ``commit`` est ``True``
par défaut.

Un autre effet de bord de l'utilisation de ``commit=False`` est visible lorsque votre modèle a une relation Plusieurs-à-Plusieurs avec un autre modèle. Si votre modèle a une relation Plusieurs-à-Plusieurs et que vous spécifiez``commit=False`` lors de la sauvegarde d'un formulaire, Django ne sauvegarde pas immédiatement les données du formulaire pour la relation Plusieurs-à-Plusieurs. Parce qu'il est impossible de sauvegarder les données Plusieurs-à-Plusieurs d'une instance tant qu'elle n'existe pas dans la base de données .

Pour contourner ce problème, chaque fois que vous sauvegardez un formulaire en utilisant ``commit=False``,
Django ajoute une méthode ``save_m2m()`` à votre sous-classe ``ModelForm``. Après avoir manuellement sauvegardé l'instance produite par le formulaire, vous pouvez invoquer ``save_m2m()`` pour sauvegarder les données Plusieurs-à-Plusieurs du formulaire. Par exemple::

    # Create a form instance with POST data.
    >>> f = AuthorForm(request.POST)

    # Create, but don't save the new author instance.
    >>> new_author = f.save(commit=False)

    # Modify the author in some way.
    >>> new_author.some_field = 'some_value'

    # Save the new instance.
    >>> new_author.save()

    # Now, save the many-to-many data for the form.
    >>> f.save_m2m()

Appeler ``save_m2m()`` n'est obligatoire que si vous utilisez ``save(commit=False)``.
Lorsque vous utilisez un simple ``save()`` sur un formulaire, toutes les données -- y compris les Plusieurs-à-Plusieurs -- sont sauvegardées sans avoir besoin d'appels de méthodes supplémentaies.
Par exemple::

    # Create a form instance with POST data.
    >>> a = Author()
    >>> f = AuthorForm(request.POST, instance=a)

    # Create and save the new author instance. There's no need to do anything else.
    >>> new_author = f.save()

À part les méthodes ``save()`` et ``save_m2m()``, un ``ModelForm`` fonctionne exactement de la même façon que tout autre formulaire ``forms``. Par exemple, la méthode ``is_valid()`` est utilisée pour vérifier la validité, la méthode ``is_multipart()`` est utilisée pour déterminer si un formulaire demande un téléchargement de fichier en plusieurs parties (et donc si ``request.FILES`` doit être passé au formulaire), etc. Voir
:ref:`binding-uploaded-files` pour plus d'informations.

Using a subset of fields on the form
------------------------------------

In some cases, you may not want all the model fields to appear on the generated
form. There are three ways of telling ``ModelForm`` to use only a subset of the
model fields:

1. Set ``editable=False`` on the model field. As a result, *any* form
   created from the model via ``ModelForm`` will not include that
   field.

2. Use the ``fields`` attribute of the ``ModelForm``'s inner ``Meta``
   class.  This attribute, if given, should be a list of field names
   to include in the form. The order in which the fields names are specified
   in that list is respected when the form renders them.

3. Use the ``exclude`` attribute of the ``ModelForm``'s inner ``Meta``
   class.  This attribute, if given, should be a list of field names
   to exclude from the form.

For example, if you want a form for the ``Author`` model (defined
above) that includes only the ``name`` and ``title`` fields, you would
specify ``fields`` or ``exclude`` like this::

    class PartialAuthorForm(ModelForm):
        class Meta:
            model = Author
            fields = ('name', 'title')

    class PartialAuthorForm(ModelForm):
        class Meta:
            model = Author
            exclude = ('birth_date',)

Since the Author model has only 3 fields, 'name', 'title', and
'birth_date', the forms above will contain exactly the same fields.

.. note::

    If you specify ``fields`` or ``exclude`` when creating a form with
    ``ModelForm``, then the fields that are not in the resulting form
    will not be set by the form's ``save()`` method. Also, if you
    manually add the excluded fields back to the form, they will not
    be initialized from the model instance.

    Django will prevent any attempt to save an incomplete model, so if
    the model does not allow the missing fields to be empty, and does
    not provide a default value for the missing fields, any attempt to
    ``save()`` a ``ModelForm`` with missing fields will fail.  To
    avoid this failure, you must instantiate your model with initial
    values for the missing, but required fields::

        author = Author(title='Mr')
        form = PartialAuthorForm(request.POST, instance=author)
        form.save()

    Alternatively, you can use ``save(commit=False)`` and manually set
    any extra required fields::

        form = PartialAuthorForm(request.POST)
        author = form.save(commit=False)
        author.title = 'Mr'
        author.save()

    See the `section on saving forms`_ for more details on using
    ``save(commit=False)``.

.. _section on saving forms: `The save() method`_

Overriding the default field types or widgets
---------------------------------------------

.. versionadded:: 1.2
    The ``widgets`` attribute is new in Django 1.2.

The default field types, as described in the `Field types`_ table above, are
sensible defaults. If you have a ``DateField`` in your model, chances are you'd
want that to be represented as a ``DateField`` in your form. But
``ModelForm`` gives you the flexibility of changing the form field type and
widget for a given model field.

To specify a custom widget for a field, use the ``widgets`` attribute of the
inner ``Meta`` class. This should be a dictionary mapping field names to widget
classes or instances.

For example, if you want the a ``CharField`` for the ``name``
attribute of ``Author`` to be represented by a ``<textarea>`` instead
of its default ``<input type="text">``, you can override the field's
widget::

    from django.forms import ModelForm, Textarea

    class AuthorForm(ModelForm):
        class Meta:
            model = Author
            fields = ('name', 'title', 'birth_date')
            widgets = {
                'name': Textarea(attrs={'cols': 80, 'rows': 20}),
            }

The ``widgets`` dictionary accepts either widget instances (e.g.,
``Textarea(...)``) or classes (e.g., ``Textarea``).

If you want to further customize a field -- including its type, label, etc. --
you can do this by declaratively specifying fields like you would in a regular
``Form``. Declared fields will override the default ones generated by using the
``model`` attribute.

For example, if you wanted to use ``MyDateFormField`` for the ``pub_date``
field, you could do the following::

    class ArticleForm(ModelForm):
        pub_date = MyDateFormField()

        class Meta:
            model = Article

If you want to override a field's default label, then specify the ``label``
parameter when declaring the form field::

   >>> class ArticleForm(ModelForm):
   ...     pub_date = DateField(label='Publication date')
   ...
   ...     class Meta:
   ...         model = Article

.. note::

    If you explicitly instantiate a form field like this, Django assumes that you
    want to completely define its behavior; therefore, default attributes (such as
    ``max_length`` or ``required``) are not drawn from the corresponding model. If
    you want to maintain the behavior specified in the model, you must set the
    relevant arguments explicitly when declaring the form field.

    For example, if the ``Article`` model looks like this::

        class Article(models.Model):
            headline = models.CharField(max_length=200, null=True, blank=True,
                                        help_text="Use puns liberally")
            content = models.TextField()

    and you want to do some custom validation for ``headline``, while keeping
    the ``blank`` and ``help_text`` values as specified, you might define
    ``ArticleForm`` like this::

        class ArticleForm(ModelForm):
            headline = MyFormField(max_length=200, required=False,
                                   help_text="Use puns liberally")

            class Meta:
                model = Article

    See the :doc:`form field documentation </ref/forms/fields>` for more information
    on fields and their arguments.

Changing the order of fields
----------------------------

By default, a ``ModelForm`` will render fields in the same order that they are
defined on the model, with ``ManyToManyField`` instances appearing last. If
you want to change the order in which fields are rendered, you can use the
``fields`` attribute on the ``Meta`` class.

The ``fields`` attribute defines the subset of model fields that will be
rendered, and the order in which they will be rendered. For example given this
model::

    class Book(models.Model):
        author = models.ForeignKey(Author)
        title = models.CharField(max_length=100)

the ``author`` field would be rendered first. If we wanted the title field
to be rendered first, we could specify the following ``ModelForm``::

    >>> class BookForm(ModelForm):
    ...     class Meta:
    ...         model = Book
    ...         fields = ('title', 'author')

.. _overriding-modelform-clean-method:

Overriding the clean() method
-----------------------------

You can override the ``clean()`` method on a model form to provide additional
validation in the same way you can on a normal form.

In this regard, model forms have two specific characteristics when compared to
forms:

By default the ``clean()`` method validates the uniqueness of fields that are
marked as ``unique``, ``unique_together`` or ``unique_for_date|month|year`` on
the model.  Therefore, if you would like to override the ``clean()`` method and
maintain the default validation, you must call the parent class's ``clean()``
method.

Also, a model form instance bound to a model object will contain a
``self.instance`` attribute that gives model form methods access to that
specific model instance.

Form inheritance
----------------

As with basic forms, you can extend and reuse ``ModelForms`` by inheriting
them. This is useful if you need to declare extra fields or extra methods on a
parent class for use in a number of forms derived from models. For example,
using the previous ``ArticleForm`` class::

    >>> class EnhancedArticleForm(ArticleForm):
    ...     def clean_pub_date(self):
    ...         ...

This creates a form that behaves identically to ``ArticleForm``, except there's
some extra validation and cleaning for the ``pub_date`` field.

You can also subclass the parent's ``Meta`` inner class if you want to change
the ``Meta.fields`` or ``Meta.excludes`` lists::

    >>> class RestrictedArticleForm(EnhancedArticleForm):
    ...     class Meta(ArticleForm.Meta):
    ...         exclude = ('body',)

This adds the extra method from the ``EnhancedArticleForm`` and modifies
the original ``ArticleForm.Meta`` to remove one field.

There are a couple of things to note, however.

* Normal Python name resolution rules apply. If you have multiple base
  classes that declare a ``Meta`` inner class, only the first one will be
  used. This means the child's ``Meta``, if it exists, otherwise the
  ``Meta`` of the first parent, etc.

* For technical reasons, a subclass cannot inherit from both a ``ModelForm``
  and a ``Form`` simultaneously.

Chances are these notes won't affect you unless you're trying to do something
tricky with subclassing.

Interaction with model validation
---------------------------------

As part of its validation process, ``ModelForm`` will call the ``clean()``
method of each field on your model that has a corresponding field on your form.
If you have excluded any model fields, validation will not be run on those
fields. See the :doc:`form validation </ref/forms/validation>` documentation
for more on how field cleaning and validation work. Also, your model's
``clean()`` method will be called before any uniqueness checks are made. See
:ref:`Validating objects <validating-objects>` for more information on the
model's ``clean()`` hook.

.. _model-formsets:

Model formsets
==============

Like :doc:`regular formsets </topics/forms/formsets>`, Django provides a couple
of enhanced formset classes that make it easy to work with Django models. Let's
reuse the ``Author`` model from above::

    >>> from django.forms.models import modelformset_factory
    >>> AuthorFormSet = modelformset_factory(Author)

This will create a formset that is capable of working with the data associated
with the ``Author`` model. It works just like a regular formset::

    >>> formset = AuthorFormSet()
    >>> print formset
    <input type="hidden" name="form-TOTAL_FORMS" value="1" id="id_form-TOTAL_FORMS" /><input type="hidden" name="form-INITIAL_FORMS" value="0" id="id_form-INITIAL_FORMS" /><input type="hidden" name="form-MAX_NUM_FORMS" id="id_form-MAX_NUM_FORMS" />
    <tr><th><label for="id_form-0-name">Name:</label></th><td><input id="id_form-0-name" type="text" name="form-0-name" maxlength="100" /></td></tr>
    <tr><th><label for="id_form-0-title">Title:</label></th><td><select name="form-0-title" id="id_form-0-title">
    <option value="" selected="selected">---------</option>
    <option value="MR">Mr.</option>
    <option value="MRS">Mrs.</option>
    <option value="MS">Ms.</option>
    </select></td></tr>
    <tr><th><label for="id_form-0-birth_date">Birth date:</label></th><td><input type="text" name="form-0-birth_date" id="id_form-0-birth_date" /><input type="hidden" name="form-0-id" id="id_form-0-id" /></td></tr>

.. note::
    ``modelformset_factory`` uses ``formset_factory`` to generate formsets.
    This means that a model formset is just an extension of a basic formset
    that knows how to interact with a particular model.

Changing the queryset
---------------------

By default, when you create a formset from a model, the formset will use a
queryset that includes all objects in the model (e.g.,
``Author.objects.all()``). You can override this behavior by using the
``queryset`` argument::

    >>> formset = AuthorFormSet(queryset=Author.objects.filter(name__startswith='O'))

Alternatively, you can create a subclass that sets ``self.queryset`` in
``__init__``::

    from django.forms.models import BaseModelFormSet

    class BaseAuthorFormSet(BaseModelFormSet):
        def __init__(self, *args, **kwargs):
            super(BaseAuthorFormSet, self).__init__(*args, **kwargs)
            self.queryset = Author.objects.filter(name__startswith='O')

Then, pass your ``BaseAuthorFormSet`` class to the factory function::

    >>> AuthorFormSet = modelformset_factory(Author, formset=BaseAuthorFormSet)

If you want to return a formset that doesn't include *any* pre-existing
instances of the model, you can specify an empty QuerySet::

   >>> AuthorFormSet(queryset=Author.objects.none())


Controlling which fields are used with ``fields`` and ``exclude``
-----------------------------------------------------------------

By default, a model formset uses all fields in the model that are not marked
with ``editable=False``. However, this can be overridden at the formset level::

    >>> AuthorFormSet = modelformset_factory(Author, fields=('name', 'title'))

Using ``fields`` restricts the formset to use only the given fields.
Alternatively, you can take an "opt-out" approach, specifying which fields to
exclude::

    >>> AuthorFormSet = modelformset_factory(Author, exclude=('birth_date',))

Providing initial values
------------------------

.. versionadded:: 1.4

As with regular formsets, it's possible to :ref:`specify initial data
<formsets-initial-data>` for forms in the formset by specifying an ``initial``
parameter when instantiating the model formset class returned by
``modelformset_factory``. However, with model formsets, the initial values only
apply to extra forms, those that aren't bound to an existing object instance.

.. _saving-objects-in-the-formset:

Saving objects in the formset
-----------------------------

As with a ``ModelForm``, you can save the data as a model object. This is done
with the formset's ``save()`` method::

    # Create a formset instance with POST data.
    >>> formset = AuthorFormSet(request.POST)

    # Assuming all is valid, save the data.
    >>> instances = formset.save()

The ``save()`` method returns the instances that have been saved to the
database. If a given instance's data didn't change in the bound data, the
instance won't be saved to the database and won't be included in the return
value (``instances``, in the above example).

When fields are missing from the form (for example because they have
been excluded), these fields will not be set by the ``save()``
method. You can find more information about this restriction, which
also holds for regular ``ModelForms``, in `Using a subset of fields on
the form`_.

Pass ``commit=False`` to return the unsaved model instances::

    # don't save to the database
    >>> instances = formset.save(commit=False)
    >>> for instance in instances:
    ...     # do something with instance
    ...     instance.save()

This gives you the ability to attach data to the instances before saving them
to the database. If your formset contains a ``ManyToManyField``, you'll also
need to call ``formset.save_m2m()`` to ensure the many-to-many relationships
are saved properly.

.. _model-formsets-max-num:

Limiting the number of editable objects
---------------------------------------

.. versionchanged:: 1.2

As with regular formsets, you can use the ``max_num`` and ``extra`` parameters
to ``modelformset_factory`` to limit the number of extra forms displayed.

``max_num`` does not prevent existing objects from being displayed::

    >>> Author.objects.order_by('name')
    [<Author: Charles Baudelaire>, <Author: Paul Verlaine>, <Author: Walt Whitman>]

    >>> AuthorFormSet = modelformset_factory(Author, max_num=1)
    >>> formset = AuthorFormSet(queryset=Author.objects.order_by('name'))
    >>> [x.name for x in formset.get_queryset()]
    [u'Charles Baudelaire', u'Paul Verlaine', u'Walt Whitman']

If the value of ``max_num`` is greater than the number of existing related
objects, up to ``extra`` additional blank forms will be added to the formset,
so long as the total number of forms does not exceed ``max_num``::

    >>> AuthorFormSet = modelformset_factory(Author, max_num=4, extra=2)
    >>> formset = AuthorFormSet(queryset=Author.objects.order_by('name'))
    >>> for form in formset:
    ...     print form.as_table()
    <tr><th><label for="id_form-0-name">Name:</label></th><td><input id="id_form-0-name" type="text" name="form-0-name" value="Charles Baudelaire" maxlength="100" /><input type="hidden" name="form-0-id" value="1" id="id_form-0-id" /></td></tr>
    <tr><th><label for="id_form-1-name">Name:</label></th><td><input id="id_form-1-name" type="text" name="form-1-name" value="Paul Verlaine" maxlength="100" /><input type="hidden" name="form-1-id" value="3" id="id_form-1-id" /></td></tr>
    <tr><th><label for="id_form-2-name">Name:</label></th><td><input id="id_form-2-name" type="text" name="form-2-name" value="Walt Whitman" maxlength="100" /><input type="hidden" name="form-2-id" value="2" id="id_form-2-id" /></td></tr>
    <tr><th><label for="id_form-3-name">Name:</label></th><td><input id="id_form-3-name" type="text" name="form-3-name" maxlength="100" /><input type="hidden" name="form-3-id" id="id_form-3-id" /></td></tr>

.. versionchanged:: 1.2

A ``max_num`` value of ``None`` (the default) puts no limit on the number of
forms displayed.

Using a model formset in a view
-------------------------------

Model formsets are very similar to formsets. Let's say we want to present a
formset to edit ``Author`` model instances::

    def manage_authors(request):
        AuthorFormSet = modelformset_factory(Author)
        if request.method == 'POST':
            formset = AuthorFormSet(request.POST, request.FILES)
            if formset.is_valid():
                formset.save()
                # do something.
        else:
            formset = AuthorFormSet()
        return render_to_response("manage_authors.html", {
            "formset": formset,
        })

As you can see, the view logic of a model formset isn't drastically different
than that of a "normal" formset. The only difference is that we call
``formset.save()`` to save the data into the database. (This was described
above, in :ref:`saving-objects-in-the-formset`.)

Overiding ``clean()`` on a ``model_formset``
--------------------------------------------

Just like with ``ModelForms``, by default the ``clean()`` method of a
``model_formset`` will validate that none of the items in the formset violate
the unique constraints on your model (either ``unique``, ``unique_together`` or
``unique_for_date|month|year``).  If you want to override the ``clean()`` method
on a ``model_formset`` and maintain this validation, you must call the parent
class's ``clean`` method::

    class MyModelFormSet(BaseModelFormSet):
        def clean(self):
            super(MyModelFormSet, self).clean()
            # example custom validation across forms in the formset:
            for form in self.forms:
                # your custom formset validation

Using a custom queryset
-----------------------

As stated earlier, you can override the default queryset used by the model
formset::

    def manage_authors(request):
        AuthorFormSet = modelformset_factory(Author)
        if request.method == "POST":
            formset = AuthorFormSet(request.POST, request.FILES,
                                    queryset=Author.objects.filter(name__startswith='O'))
            if formset.is_valid():
                formset.save()
                # Do something.
        else:
            formset = AuthorFormSet(queryset=Author.objects.filter(name__startswith='O'))
        return render_to_response("manage_authors.html", {
            "formset": formset,
        })

Note that we pass the ``queryset`` argument in both the ``POST`` and ``GET``
cases in this example.

Using the formset in the template
---------------------------------

.. highlight:: html+django

There are three ways to render a formset in a Django template.

First, you can let the formset do most of the work::

    <form method="post" action="">
        {{ formset }}
    </form>

Second, you can manually render the formset, but let the form deal with
itself::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {{ form }}
        {% endfor %}
    </form>

When you manually render the forms yourself, be sure to render the management
form as shown above. See the :ref:`management form documentation
<understanding-the-managementform>`.

Third, you can manually render each field::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {% for field in form %}
                {{ field.label_tag }}: {{ field }}
            {% endfor %}
        {% endfor %}
    </form>

If you opt to use this third method and you don't iterate over the fields with
a ``{% for %}`` loop, you'll need to render the primary key field. For example,
if you were rendering the ``name`` and ``age`` fields of a model::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {{ form.id }}
            <ul>
                <li>{{ form.name }}</li>
                <li>{{ form.age }}</li>
            </ul>
        {% endfor %}
    </form>

Notice how we need to explicitly render ``{{ form.id }}``. This ensures that
the model formset, in the ``POST`` case, will work correctly. (This example
assumes a primary key named ``id``. If you've explicitly defined your own
primary key that isn't called ``id``, make sure it gets rendered.)

.. highlight:: python

Inline formsets
===============

Inline formsets is a small abstraction layer on top of model formsets. These
simplify the case of working with related objects via a foreign key. Suppose
you have these two models::

    class Author(models.Model):
        name = models.CharField(max_length=100)

    class Book(models.Model):
        author = models.ForeignKey(Author)
        title = models.CharField(max_length=100)

If you want to create a formset that allows you to edit books belonging to
a particular author, you could do this::

    >>> from django.forms.models import inlineformset_factory
    >>> BookFormSet = inlineformset_factory(Author, Book)
    >>> author = Author.objects.get(name=u'Mike Royko')
    >>> formset = BookFormSet(instance=author)

.. note::
    ``inlineformset_factory`` uses ``modelformset_factory`` and marks
    ``can_delete=True``.

.. seealso::

    :ref:`Manually rendered can_delete and can_order <manually-rendered-can-delete-and-can-order>`.

More than one foreign key to the same model
-------------------------------------------

If your model contains more than one foreign key to the same model, you'll
need to resolve the ambiguity manually using ``fk_name``. For example, consider
the following model::

    class Friendship(models.Model):
        from_friend = models.ForeignKey(Friend)
        to_friend = models.ForeignKey(Friend)
        length_in_months = models.IntegerField()

To resolve this, you can use ``fk_name`` to ``inlineformset_factory``::

    >>> FriendshipFormSet = inlineformset_factory(Friend, Friendship, fk_name="from_friend")

Using an inline formset in a view
---------------------------------

You may want to provide a view that allows a user to edit the related objects
of a model. Here's how you can do that::

    def manage_books(request, author_id):
        author = Author.objects.get(pk=author_id)
        BookInlineFormSet = inlineformset_factory(Author, Book)
        if request.method == "POST":
            formset = BookInlineFormSet(request.POST, request.FILES, instance=author)
            if formset.is_valid():
                formset.save()
                # Do something.
        else:
            formset = BookInlineFormSet(instance=author)
        return render_to_response("manage_books.html", {
            "formset": formset,
        })

Notice how we pass ``instance`` in both the ``POST`` and ``GET`` cases.
