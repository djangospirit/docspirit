==============
URL dispatcher
==============

.. module:: django.core.urlresolvers

Un système d'URLs propre, élégant, est un aspect important dans une application Web de qualité. Django vous permet de concevoir vos URL de la façon qui vous convient le mieux, sans limitations dues au framework.

Il n'y a pas d'obligation d'insérer ``.php`` ou ``.cgi`` dans l'URL, et encore moins ce type d'absurdités :
``0,2097,1-1-1928,00``.

Consultez `Cool URIs don't change`_, par Tim Berners-Lee, le créateur du World Wide Web, pour une excellente argumentation expliquant pourquoi les URLs doivent être propres et utilisables.

.. _Cool URIs don't change: http://www.w3.org/Provider/Style/URI

Vue d'ensemble
==============

Pour créer les URLs d'une application, vous créez un module Python simplement appelé
**URLconf** (URL configuration). Ce module n'est rien d'autre que du code Python pur et il s'agit d'un simple mappage de motifs d'URL sous forme d'expressions rationnelles (*URL patterns*) vers des fonctions callback Python (vos vues).

Ce mappage est aussi bref ou aussi long que nécessaire. Il peut se référer à d'autres mappages. Et, parce qu'il s'agit de code Python pur, il peut être construit dynamiquement.

.. versionadded:: 1.4
    Django permet également la traduction d'URL en fonction de la langue active.
    Le processus est décrit dans 
    :ref:`internationalization docs <url-internationalization>`.

.. _how-django-processes-a-request:

Comment une requête est traitée par Django
==========================================

Lorsqu'un utilisateur demande une page, voici l'algorithme suivi par le système pour déterminer quel code Python exécuter:

1. Django détermine le module URLconf racine à utiliser. D'ordinaire, c'est la valeur du paramètre :setting:`ROOT_URLCONF` , mais si l'objet ``HttpRequest`` entrant a un attribut appelé ``urlconf`` (paramétré par le
   middleware :ref:`request processing <request-middleware>`), sa valeur sera utilisée à la place du paramètre :setting:`ROOT_URLCONF`.

2. Django charge ce module Python et cherche la variable ``urlpatterns``. Il s'agit d'une liste Python, au format retourné par la fonction :func:`django.conf.urls.patterns`.

3. Django parcourt chaque motif URL, dans l'ordre, et s'arrête au premier qui correspond à l'URL demandée.

4. Dès que l'une des expressions rationnelles correspond, Django importe et appelle la vue indiquée, qui est une simple fonction Python. La vue reçoit un :class:`~django.http.HttpRequest` en premier argument et toutes valeurs capturées par l'expression rationnelle en arguments suivants.

5. Si aucune expression rationnelle ne correspond, ou si une exception est levée à un moment donné de ce traitement, Django invoque une vue error-handling appropriée. Voir `Error handling`_ ci-dessous.

Exemple
=======

Voici un échantillon d'URLconf::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('',
        (r'^articles/2003/$', 'news.views.special_case_2003'),
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

Notes:

* Pour capturer une valeur de l'URL, mettez-la simplement entre parenthèses.

* Il n'est pas nécessaire d'ajouter le slash de début, parce que chaque URL en a. Par exemple, c'est ``^articles``, pas ``^/articles``.

* Le ``'r'`` au début de chaque expression rationnelle est facultatif mais conseillé. Il dit à Python qu'une chaîne est "brute" ("raw") -- que rien dans la chaîne ne doit être échappé. Voir `Dive Into Python`_.

Exemple de requêtes:

* Une requête vers ``/articles/2005/03/`` correspondra à la troisième entrée de la liste. Django appellera la fonction
  ``news.views.month_archive(request, '2005', '03')``.

* ``/articles/2005/3/`` ne correspondra à aucun des motifs d'URL, parce que la troisième entrée de la liste requiert 2 chiffres pour le mois.

* ``/articles/2003/`` correspondra au premier motif de la liste, pas au second, parce que les motifs sont testés dans l'ordre, et le premier est le premier à réussier le test. N'hésitez pas à exploiter l'ordre pour insérer des cas particuliers comme celui-ci.

* ``/articles/2003`` ne correspondra à aucun de ces motifs, parce que chaque motif exige que l'URL se termine par un slash.

* ``/articles/2003/03/03/`` correspondra au dernier motif. Django appellera la fonction ``news.views.article_detail(request, '2003', '03', '03')``.

.. _Dive Into Python: http://diveintopython.adrahon.org/regular_expressions/street_addresses.html

Groupes nommés
==============

Pour capturer les parties de l'URL et les passer en arguments positionnels à une vue, l'exemple précédent utilise des groupes d'expressions rationnelles simples, *non nommées* (via des parenthèses). Dans un usage plus avancé, il est possible d'utiliser des goupes d'expressions rationnelles *nommés* pour capturer des parties d'URL et les passer en tant qu'arguments *mots-clé* à une vue.

Dans les expressions rationnellles Python, la syntaxe pour les groupes nommés d'expressions rationnelles est ``(?P<name>pattern)``, où ``name`` est le nom du groupe et ``pattern`` est le motif à rechercher.

Voicie le précédent exemple URLconf, ré-écrit pour utiliser les groupes nommés::

    urlpatterns = patterns('',
        (r'^articles/2003/$', 'news.views.special_case_2003'),
        (r'^articles/(?P<year>\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})/$', 'news.views.article_detail'),
    )

Ce code exécute exactement la même chose que l'exemple précédent, avec une différence subtile: les valeurs capturées sont passées aux fonctions vues comme arguments mots-clés plutôt que comme arguments positionnels. Par exemple:

* Une requête vers ``/articles/2005/03/`` appellera la fonction 
  ``news.views.month_archive(request, year='2005', month='03')``, au lieu de ``news.views.month_archive(request, '2005', '03')``.

* Une requête vers ``/articles/2003/03/03/`` appellera la fonction 
  ``news.views.article_detail(request, year='2003', month='03', day='03')``.

En pratique, cela veut dire que vos URLconfs sont légèrement plus explicites et moins sujets à des bugs relatifs à l'ordre des arguments -- et vous pouvez reordonner les arguments dans vos déclarations de fonctions vue. Bien sûr, ces avantages se font aux dépens de la concision; certains développeurs trouvent la syntaxe groupes nommées laide et trop bavarde.

L'algorithme correspondance/grouping
------------------------------------

Voici l'algorithme que le parser URLconfsuit, par rapport aux groupes nommés vs groupes non nommés d'une expression rationnelle:

S'il trouve des arguments nommés, il les utilisera et ignorera les arguments non nommés. Sinon, il passera tous les arguments non nommés en tant qu'arguments positionnels.

Dans les deux cas, il passera tout argument mot-clé supplémentaire comme argument mot-clé. Voir  In both cases, it will pass any extra keyword arguments as keyword arguments.
Voir "Passer des options supplémentaires aux fonctions vue" ci-dessous.

Ce que URLconf recherche
========================

URLconf fait sa recherche sur l'URL demandée, en tant que chaîne Python normale. Cela n'inclut pas les paramètres GET ou POST, ou le nom de domaine.

Par exemple, s ``http://www.example.com/myapp/``, URLconf cherchera ``myapp/``.

Sur une requête pour ``http://www.example.com/myapp/?page=3``, URLconf cherchera ``myapp/``.

URLconf ne regarde pas la méthode de requête. En d'autres termes, toutes les méthodes de requêtes -- ``POST``, ``GET``, ``HEAD``, etc. -- de la même URL seront dirigées vers la même fonction.

Syntaxe de la variable urlpatterns
==================================

``urlpatterns`` doit être une liste Python, au format retourné par la fonction :func:`django.conf.urls.patterns`. Utilisez toujours ``patterns()`` pour créer la variable ``urlpatterns``.

Fonctions utilitraires ``django.conf.urls``
===========================================

.. module:: django.conf.urls

.. deprecated:: 1.4
    A partir de  Django 1.4 les fonctions ``patterns``, ``url``, ``include`` et les symboles ``handler*`` décrits ci-dessous se trouvent dans le module ``django.conf.urls``.

    Jusqu'à Django 1.3 ils étaient situés dans ``django.conf.urls.defaults``. Vous pouvez encore les importer depuis ce module mais ils disparaîtront dans Django 1.6.

patterns
--------

.. function:: patterns(prefix, pattern_description, ...)

Une fonction qui prend un prefix et un nombre quelconque de motifs d'URL, et retourne une liste de de motifs d'URL dans un format requis par Django.

Le premier argument de ``patterns()`` est une chaîne ``prefix``. Voir 
`Le préfixe de vue`_ plus loin.

Les arguments restants doivent être des tuples dans ce format::

    (regular expression, Python callback function [, optional dictionary [, optional name]])

...où ``optional dictionary`` et ``optional name`` sont optionnels. (Voir
`Passer des options supplémentaires aux fonctions vue`_ ci-dessous.)

.. note::
    Parce que `patterns()` est un appel de fonction, il accepte un maximum de 255
    arguments (des motifs d'URL dans le cas présent). C'est une limitation des appels de fonction Python. 
    En pratique, c'est rarement un problème parce que vous structurerez vos motifs d'URL modulairement en utilisant des sections  `include()`. Cependant, si par miracle vous atteignez la limite des 255 arguments, sachez que `patterns()` renvoie une liste Python, vous pouvez donc divisier la construction de la liste.

    ::

        urlpatterns = patterns('',
            ...
            )
        urlpatterns += patterns('',
            ...
            )

    Les listes Python ont une taille illmitée, il n'y a donc pas de limite au nombre de motifs d'URL que vous pouvez construire. LA seule limite est que vous ne pouvez en créer que 254 à la fois (le 255e argument est l'argument prefixe initial).

url
---

.. function:: url(regex, view, kwargs=None, name=None, prefix='')

Vous pouvez utiliser la fonction ``url()``, au lieu d'un tuple, en tant qu'argument pour
``patterns()``. C'est pratique si vous voulez spécifier un nom sans ledictionnaire d'arguments supplémentaires optionnels. Par exemple::

    urlpatterns = patterns('',
        url(r'^index/$', index_view, name="main-view"),
        ...
    )

Cette fonction prend cinq arguments, la plupart sont optionnels::

    url(regex, view, kwargs=None, name=None, prefix='')

Voir `Nommer les motifs d'URL`_ pour savoir pourquoi le paramètre ``name`` est utile.

Le paramètre ``prefix`` a le même sens que le premier argument pour
``patterns()`` et il n'est pertinent que lorsque vous passez une chaîne comme paramètre ``view``.

include
-------

.. function:: include(<module or pattern_list>)

Une fonction qui prend un chemin d'import Python entier vers un autre module URLconf qui doit être "inclus" à cet endroit.

:func:`include` accepte également comme argument un itérable qui renvoie URL
patterns.

Voir `Inclure d'autres URLconfs`_ ci-dessous.

Gestion des erreurs
===================

Lorsque Django ne peut trouver une regex correspondant à l'URL demandée, ou lorsque une exception est levée, Django invoquera une vue gestionjnaire d'erreur. Les vues à utiliser dans ces cas-là sont spécifiées par trois variables qui peuvent être initialisées dans votre URLconf racine. Initialiser ces variables dans n'importe quel autre URLconf sera sans effet.

Voir la documentation sur :ref:`customizing error views
<customizing-error-views>` pour plus de détails.

handler403
----------

.. data:: handler403

Un appelable, ou une chaîne représentant le chemin d'import Python complet sur la vue devant être appelée si l'utilisateur n'a pas les droits requis pour accèder à une ressource.

Par défaut, il s'agit de ``'django.views.defaults.permission_denied'``. Cette valeur par défaut devrait faire l'affaire.

Voir la documentation sur :ref:`the 403 (HTTP Forbidden) view
<http_forbidden_view>` plus pour d'informations.

.. versionadded:: 1.4
    ``handler403`` is new in Django 1.4.

handler404
----------

.. data:: handler404

Un appelable, ou une chaîne représentant le chemin d'import Python complet sur la vue devant être appelée si aucun des motifs URL ne correspond.

Par défaut, il s'agit de ``'django.views.defaults.page_not_found'``. Cette valeur par défaut devrait faire l'affaire.

.. versionchanged:: 1.2
    Les précédentes versions de Django n'acceptaient que des chaînes représentant les chemins d'import.

handler500
----------

.. data:: handler500

Un appelable, ou une chaîne représentant le chemin d'import Python complet sur la vue devant être appelée en cas d'erreurs serveurs. Les erreurs serveurs se produisent lorsque vous avez des erreurs d'exécution dans le code vue.

Par défaut, il s'agit de ``'django.views.defaults.server_error'``. Cette valeur par défaut devrait faire l'affaire.

.. versionchanged:: 1.2
    Les précédentes versions de Django n'acceptaient que des chaînes représentant les chemins d'import.


Notes sur la capture de texte dans les URLs
===========================================

Chaque argument capturé est envoyé à la vue en tant que texte Python simple, indépendamment du type de corespondance que font les expressions rationnelles. Par exemple, dans cette ligne URLconf::

    (r'^articles/(?P<year>\d{4})/$', 'news.views.year_archive'),

...l'argument ``year`` pour ``news.views.year_archive()`` sera une chaîne, pas un entier, même si ``\d{4}`` ne correspondra qu'à des entiers sous forme de chaîne.

Un truc commode est de spécifier les paramètrespar défaut pour vos arguments de vues. Voici un exemple URLconf et vue::

    # URLconf
    urlpatterns = patterns('',
        (r'^blog/$', 'blog.views.page'),
        (r'^blog/page(?P<num>\d+)/$', 'blog.views.page'),
    )

    # View (in blog/views.py)
    def page(request, num="1"):
        # Output the appropriate page of blog entries, according to num.

Dans cet exemple, les deux motifs URL pointent vers la même vue --
``blog.views.page`` -- mais le premier motif ne capture rien de l'URL. Si le premier motif correspond, la fonction ``page()`` utilisera son argument par défaut pour ``num``, ``"1"``. Si le deuxième motif correspond, ``page()`` utilisera n'importe quel valeur ``num`` capturée par l'expression rationnelle.

Performance
===========

Chaque expression rationnelle d'un ``urlpatterns`` est compilé lors de son premier accès. Cela rend le système furieusement rapide.

Le préfixe de vue
=================

Vous pouvez spécifier un prefix commun à votre appel de ``patterns()``, pour réduire la duplication de code.

Voici l'exemple URLconf de :doc:`Django overview </intro/overview>`::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

Dans cet exemple, chaque vue a un préfixe commun -- ``'news.views'``.
Au lieu de le retaper pour chaque entrée dans  ``urlpatterns``, vous pouvez utiliser le premier argument de la fonction ``patterns()`` pour spécifier un préfixe à appliquer à chaque fonction vue.

Avec cela, l'exemple précédent s'écrira de manière plus concise::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('news.views',
        (r'^articles/(\d{4})/$', 'year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'article_detail'),
    )

Notez que vous ne mettez pas de point final (``"."``) au préfixe. Django le fait automatiquement.

Préfixes de vues multiples
--------------------------

En pratique, vous finirez probablement par mélanger les vues au point qu'elles n'auront pas de préfixe commun dans votre ``urlpatterns``. Vous pouvez cependant continuer à tirer partie du raccourci par le préfixe pour les vues pour éviter la duplication de code. Ajoutez simplement plusieurs objets ``patterns()`` ensemble, comme ceci:

Avant::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('',
        (r'^$', 'django.views.generic.date_based.archive_index'),
        (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$', 'django.views.generic.date_based.archive_month'),
        (r'^tag/(?P<tag>\w+)/$', 'weblog.views.tag'),
    )

Après::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('django.views.generic.date_based',
        (r'^$', 'archive_index'),
        (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$','archive_month'),
    )

    urlpatterns += patterns('weblog.views',
        (r'^tag/(?P<tag>\w+)/$', 'tag'),
    )

Inclure d'autres URLconfs
=========================

À tout moment, votre ``urlpatterns`` peut "inclure" d'autres modules URLconf. *This
essentially "roots" a set of URLs below other ones*.

Par exemple, voici un extrait de l'URLconf du `Django Web site`_. Il inclut un certain nombre d'autres URLconfs::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('',
        # ... snip ...
        (r'^comments/', include('django.contrib.comments.urls')),
        (r'^community/', include('django_website.aggregator.urls')),
        (r'^contact/', include('django_website.contact.urls')),
        (r'^r/', include('django.conf.urls.shortcut')),
        # ... snip ...
    )

Notez que les expressions rationnelles de cet exemple n'ont pas de  ``$``
(caractère de fin de ligne ) mais incluent un slash de fin. Chaque fois que 
Django rencontre ``include()``, il coupe les parties de l'URL qui correspondaient à ce stade et envoie la chaîne restante à l'URLconf inclue pour la suite du traitement.

Une autre possibilité est d'inclure les motifs d'URL supplémentaires non pas en spécifiant le module Python URLconf qui les définit en argument pour `include`_ mais en utilisant directement la liste de motifs telle qu'elle est renvoyée par `patterns`_. Par exemple::

    from django.conf.urls import patterns, url, include

    extra_patterns = patterns('',
        url(r'^reports/(?P<id>\d+)/$', 'credit.views.report', name='credit-reports'),
        url(r'^charge/$', 'credit.views.charge', name='credit-charge'),
    )

    urlpatterns = patterns('',
        url(r'^$', 'apps.main.views.homepage', name='site-homepage'),
        (r'^help/', include('apps.help.urls')),
        (r'^credit/', include(extra_patterns)),
    )

L'utilisation de cette approche peut être vue lorsque vous déployez une instance de l'application Django
Admin. The Django Admin est déployée en tant qu'instance de :class:`~django.contrib.admin.AdminSite`; chaque instance
:class:`~django.contrib.admin.AdminSite` a un attribut ``urls`` qui renvoie le motif d'url disponible pour cette instance. C'est cet attribut que vous ``include()`` dans vos projets ``urlpatterns`` lorsque vous déployez l'instance admin.

.. _`Django Web site`: https://www.djangoproject.com/

Paramètres capturés
-------------------

Un URLconf inclus reçoit n'importe quel paramètre capturé des URLconfs parents, aussi, l'exemple suivant est valable::

    # Dans settings/urls/main.py
    urlpatterns = patterns('',
        (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
    )

    # Dans foo/urls/blog.py
    urlpatterns = patterns('foo.views',
        (r'^$', 'blog.index'),
        (r'^archive/$', 'blog.archive'),
    )

Dans cet exemple, la variable capturée ``"username"`` est passée à l'URLconf inclus, comme attendu.

.. _topics-http-defining-url-namespaces:

Déclarer des namespaces URL
---------------------------

Lorsque vous devez déployer de multiples instances d'une seule application, il peut être pratique de pouvoir en différencier les instances. C'est particulièrement important avec l'utilisation de :ref:`named URL patterns <naming-url-patterns>`, puisque de multiples instances d'une même application partageront les URLs nommées. Les espaces de noms fournissent un moyen de désigner ces URLs nommés à part.

Un espace de nom URL est composé de deux parties, toutes deux étant des chaînes:

* Un **espace de nom application**. Il décrit le nom de  l'application déployée.
  Chaque instance d'une même application aura le même espace de nom application.
  Par exemple, l'application admin de Django a l'espace de nom prévisible ``admin``.

* Un **espace de nom instance**. Il identifie l'instance spécifique d'une application.
  Les espaces de nom Instance doivent être unique dans tout votre projet. 
  Toutefois, un espace de nom instance peut être le même que l'espace de nom application. 
  Cela  sert à désigner l'instance par défaut d'une application. 
  Par exemple, l'instance par défaut de l'application Admin Django a un espace de nom ``admin``.

Les espaces de nom URL peuvent être déclarés de deux façons.

En premier lieu, vous pouvez fournir les espaces de nom application et instances en argument à ``include()`` lorsque vous construisez vos motifs d'URL. Par exemple::

    (r'^help/', include('apps.help.urls', namespace='foo', app_name='bar')),

Cela inclut les URLs déclarées dans ``apps.help.urls`` à l'intérieur de l'espace de nom application ``bar``, avec l'espace de nom instance ``foo``.

Deuxièmement, vous pouvez inclure un objet qui contient des données espaces de nom embarquées. Si vous ``include()`` un objet ``patterns``, cet objet sera ajouté à l'espace de nom global. Vous pouvez cependant aussi ``include()`` un objet qui contient un 3-tuple qui contiennent::

    (<patterns object>, <application namespace>, <instance namespace>)

Cela incluera les motifs d'URL désignés à l'intérieur de l'application donnée et l'espace de nom instance. Par exemple, l'attribut ``urls`` de l'objet :class:`~django.contrib.admin.AdminSite` de Django retourne un 3-tuple qui contient tous les motifs d'un site admin, plus le nom de l'instance admin, et l'espace de nom application ``admin``.

Une fois que les espaces de nom URL sont déclarées, vous pouvez les Once you have defined namespaced URLs, you can reverse them. For details on
reversing namespaced urls, see the documentation on :ref:`reversing namespaced
URLs <topics-http-reversing-url-namespaces>`.

Passer des options supplémentaires aux fonctions vue
====================================================

Les URLconfs ont un hook qui vous permet de passer des arguments supplémentaires à vos fonctions vues, via un dictionnaire Python.

Chaque tuple URLconf peut avoir un troisième élément optionnel, qui doit être un dictionnaire d'arguments mot-clé à passer à la fonction vue.

Par exemple::

    urlpatterns = patterns('blog.views',
        (r'^blog/(?P<year>\d{4})/$', 'year_archive', {'foo': 'bar'}),
    )

Dans cet exemple, pour une requête vers ``/blog/2005/``, Django appelera la vue
``blog.views.year_archive()``, en lui passant ces arguments mot-clé::

    year='2005', foo='bar'

Cette technique est utilisée dans :doc:`generic views </ref/generic-views>` et dans le
:doc:`syndication framework </ref/contrib/syndication>` pour passer des metadata et des options aux vues.

.. admonition:: Gérer les conflits

    Il est possible d'avoir un motif d'URL qui capture les arguments mot-clé nommés,
    et passe également des arguments avec les même noms dans ses dictionnaires d'arguments supplémentaires. 
    Quand cela arrive, les arguments dans le dictionnaire seront utilisés à la place des arguments capturés dans l'URL.

Passer des options supplémentaires à ``include()``
--------------------------------------------------

De même, vous pouvez passer des options supplémentaires à ``include()``. Lorsque vous le faites, *chaque* ligne de l'URLconf inclus sera in the included URLconf will be passed
the extra options.

For example, these two URLconf sets are functionally identical:

Set one::

    # main.py
    urlpatterns = patterns('',
        (r'^blog/', include('inner'), {'blogid': 3}),
    )

    # inner.py
    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive'),
        (r'^about/$', 'mysite.views.about'),
    )

Set two::

    # main.py
    urlpatterns = patterns('',
        (r'^blog/', include('inner')),
    )

    # inner.py
    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
        (r'^about/$', 'mysite.views.about', {'blogid': 3}),
    )

Note that extra options will *always* be passed to *every* line in the included
URLconf, regardless of whether the line's view actually accepts those options
as valid. For this reason, this technique is only useful if you're certain that
every view in the included URLconf accepts the extra options you're passing.

Passing callable objects instead of strings
===========================================

Some developers find it more natural to pass the actual Python function object
rather than a string containing the path to its module. This alternative is
supported -- you can pass any callable object as the view.

For example, given this URLconf in "string" notation::

    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive'),
        (r'^about/$', 'mysite.views.about'),
        (r'^contact/$', 'mysite.views.contact'),
    )

You can accomplish the same thing by passing objects rather than strings. Just
be sure to import the objects::

    from mysite.views import archive, about, contact

    urlpatterns = patterns('',
        (r'^archive/$', archive),
        (r'^about/$', about),
        (r'^contact/$', contact),
    )

The following example is functionally identical. It's just a bit more compact
because it imports the module that contains the views, rather than importing
each view individually::

    from mysite import views

    urlpatterns = patterns('',
        (r'^archive/$', views.archive),
        (r'^about/$', views.about),
        (r'^contact/$', views.contact),
    )

The style you use is up to you.

Note that if you use this technique -- passing objects rather than strings --
the view prefix (as explained in "The view prefix" above) will have no effect.

.. _naming-url-patterns:

Nommer les motifs d'URL
======================

It's fairly common to use the same view function in multiple URL patterns in
your URLconf. For example, these two URL patterns both point to the ``archive``
view::

    urlpatterns = patterns('',
        (r'^archive/(\d{4})/$', archive),
        (r'^archive-summary/(\d{4})/$', archive, {'summary': True}),
    )

This is completely valid, but it leads to problems when you try to do reverse
URL matching (through the ``permalink()`` decorator or the :ttag:`url` template
tag). Continuing this example, if you wanted to retrieve the URL for the
``archive`` view, Django's reverse URL matcher would get confused, because *two*
URL patterns point at that view.

To solve this problem, Django supports **named URL patterns**. That is, you can
give a name to a URL pattern in order to distinguish it from other patterns
using the same view and parameters. Then, you can use this name in reverse URL
matching.

Here's the above example, rewritten to use named URL patterns::

    urlpatterns = patterns('',
        url(r'^archive/(\d{4})/$', archive, name="full-archive"),
        url(r'^archive-summary/(\d{4})/$', archive, {'summary': True}, "arch-summary"),
    )

With these names in place (``full-archive`` and ``arch-summary``), you can
target each pattern individually by using its name:

.. code-block:: html+django

    {% url arch-summary 1945 %}
    {% url full-archive 2007 %}

Even though both URL patterns refer to the ``archive`` view here, using the
``name`` parameter to ``url()`` allows you to tell them apart in templates.

The string used for the URL name can contain any characters you like. You are
not restricted to valid Python names.

.. note::

    When you name your URL patterns, make sure you use names that are unlikely
    to clash with any other application's choice of names. If you call your URL
    pattern ``comment``, and another application does the same thing, there's
    no guarantee which URL will be inserted into your template when you use
    this name.

    Putting a prefix on your URL names, perhaps derived from the application
    name, will decrease the chances of collision. We recommend something like
    ``myapp-comment`` instead of ``comment``.

.. _topics-http-reversing-url-namespaces:

URL namespaces
--------------

Namespaced URLs are specified using the ``:`` operator. For example, the main
index page of the admin application is referenced using ``admin:index``. This
indicates a namespace of ``admin``, and a named URL of ``index``.

Namespaces can also be nested. The named URL ``foo:bar:whiz`` would look for
a pattern named ``whiz`` in the namespace ``bar`` that is itself defined within
the top-level namespace ``foo``.

When given a namespaced URL (e.g. ``myapp:index``) to resolve, Django splits
the fully qualified name into parts, and then tries the following lookup:

1. First, Django looks for a matching application namespace (in this
   example, ``myapp``). This will yield a list of instances of that
   application.

2. If there is a *current* application defined, Django finds and returns
   the URL resolver for that instance. The *current* application can be
   specified as an attribute on the template context - applications that
   expect to have multiple deployments should set the ``current_app``
   attribute on any ``Context`` or ``RequestContext`` that is used to
   render a template.

   The current application can also be specified manually as an argument
   to the :func:`reverse()` function.

3. If there is no current application. Django looks for a default
   application instance. The default application instance is the instance
   that has an instance namespace matching the application namespace (in
   this example, an instance of the ``myapp`` called ``myapp``).

4. If there is no default application instance, Django will pick the last
   deployed instance of the application, whatever its instance name may be.

5. If the provided namespace doesn't match an application namespace in
   step 1, Django will attempt a direct lookup of the namespace as an
   instance namespace.

If there are nested namespaces, these steps are repeated for each part of the
namespace until only the view name is unresolved. The view name will then be
resolved into a URL in the namespace that has been found.

To show this resolution strategy in action, consider an example of two instances
of ``myapp``: one called ``foo``, and one called ``bar``. ``myapp`` has a main
index page with a URL named `index`. Using this setup, the following lookups are
possible:

* If one of the instances is current - say, if we were rendering a utility page
  in the instance ``bar`` - ``myapp:index`` will resolve to the index page of
  the instance ``bar``.

* If there is no current instance - say, if we were rendering a page
  somewhere else on the site - ``myapp:index`` will resolve to the last
  registered instance of ``myapp``. Since there is no default instance,
  the last instance of ``myapp`` that is registered will be used. This could
  be ``foo`` or ``bar``, depending on the order they are introduced into the
  urlpatterns of the project.

* ``foo:index`` will always resolve to the index page of the instance ``foo``.

If there was also a default instance - i.e., an instance named `myapp` - the
following would happen:

* If one of the instances is current - say, if we were rendering a utility page
  in the instance ``bar`` - ``myapp:index`` will resolve to the index page of
  the instance ``bar``.

* If there is no current instance - say, if we were rendering a page somewhere
  else on the site - ``myapp:index`` will resolve to the index page of the
  default instance.

* ``foo:index`` will again resolve to the index page of the instance ``foo``.


``django.core.urlresolvers`` utility functions
==============================================

.. currentmodule:: django.core.urlresolvers

reverse()
---------

If you need to use something similar to the :ttag:`url` template tag in
your code, Django provides the following function (in the
:mod:`django.core.urlresolvers` module):

.. function:: reverse(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])

``viewname`` is either the function name (either a function reference, or the
string version of the name, if you used that form in ``urlpatterns``) or the
`URL pattern name`_.  Normally, you won't need to worry about the
``urlconf`` parameter and will only pass in the positional and keyword
arguments to use in the URL matching. For example::

    from django.core.urlresolvers import reverse

    def myview(request):
        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))

.. _URL pattern name: `Nommer les motifs d'URL`_

The ``reverse()`` function can reverse a large variety of regular expression
patterns for URLs, but not every possible one. The main restriction at the
moment is that the pattern cannot contain alternative choices using the
vertical bar (``"|"``) character. You can quite happily use such patterns for
matching against incoming URLs and sending them off to views, but you cannot
reverse such patterns.

The ``current_app`` argument allows you to provide a hint to the resolver
indicating the application to which the currently executing view belongs.
This ``current_app`` argument is used as a hint to resolve application
namespaces into URLs on specific application instances, according to the
:ref:`namespaced URL resolution strategy <topics-http-reversing-url-namespaces>`.

You can use ``kwargs`` instead of ``args``. For example::

    >>> reverse('admin:app_list', kwargs={'app_label': 'auth'})
    '/admin/auth/'

``args`` and ``kwargs`` cannot be passed to ``reverse()`` at the same time.

.. admonition:: Make sure your views are all correct.

    As part of working out which URL names map to which patterns, the
    ``reverse()`` function has to import all of your URLconf files and examine
    the name of each view. This involves importing each view function. If
    there are *any* errors whilst importing any of your view functions, it
    will cause ``reverse()`` to raise an error, even if that view function is
    not the one you are trying to reverse.

    Make sure that any views you reference in your URLconf files exist and can
    be imported correctly. Do not include lines that reference views you
    haven't written yet, because those views will not be importable.

.. note::

    The string returned by :meth:`~django.core.urlresolvers.reverse` is already
    :ref:`urlquoted <uri-and-iri-handling>`. For example::

        >>> reverse('cities', args=[u'Orléans'])
        '.../Orl%C3%A9ans/'

    Applying further encoding (such as :meth:`~django.utils.http.urlquote` or
    ``urllib.quote``) to the output of :meth:`~django.core.urlresolvers.reverse`
    may produce undesirable results.

reverse_lazy()
--------------

.. versionadded:: 1.4

A lazily evaluated version of `reverse()`_.

.. function:: reverse_lazy(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])

It is useful for when you need to use a URL reversal before your project's
URLConf is loaded. Some common cases where this function is necessary are:

* providing a reversed URL as the ``url`` attribute of a generic class-based
  view.

* providing a reversed URL to a decorator (such as the ``login_url`` argument
  for the :func:`django.contrib.auth.decorators.permission_required`
  decorator).

* providing a reversed URL as a default value for a parameter in a function's
  signature.

resolve()
---------

The :func:`django.core.urlresolvers.resolve` function can be used for
resolving URL paths to the corresponding view functions. It has the
following signature:

.. function:: resolve(path, urlconf=None)

``path`` is the URL path you want to resolve. As with
:func:`~django.core.urlresolvers.reverse`, you don't need to
worry about the ``urlconf`` parameter. The function returns a
:class:`ResolverMatch` object that allows you
to access various meta-data about the resolved URL.

If the URL does not resolve, the function raises an
:class:`~django.http.Http404` exception.

.. class:: ResolverMatch

    .. attribute:: ResolverMatch.func

        The view function that would be used to serve the URL

    .. attribute:: ResolverMatch.args

        The arguments that would be passed to the view function, as
        parsed from the URL.

    .. attribute:: ResolverMatch.kwargs

        The keyword arguments that would be passed to the view
        function, as parsed from the URL.

    .. attribute:: ResolverMatch.url_name

        The name of the URL pattern that matches the URL.

    .. attribute:: ResolverMatch.app_name

        The application namespace for the URL pattern that matches the
        URL.

    .. attribute:: ResolverMatch.namespace

        The instance namespace for the URL pattern that matches the
        URL.

    .. attribute:: ResolverMatch.namespaces

        The list of individual namespace components in the full
        instance namespace for the URL pattern that matches the URL.
        i.e., if the namespace is ``foo:bar``, then namespaces will be
        ``['foo', 'bar']``.

A :class:`ResolverMatch` object can then be interrogated to provide
information about the URL pattern that matches a URL::

    # Resolve a URL
    match = resolve('/some/path/')
    # Print the URL pattern that matches the URL
    print match.url_name

A :class:`ResolverMatch` object can also be assigned to a triple::

    func, args, kwargs = resolve('/some/path/')

.. versionchanged:: 1.3
    Triple-assignment exists for backwards-compatibility. Prior to
    Django 1.3, :func:`~django.core.urlresolvers.resolve` returned a
    triple containing (view function, arguments, keyword arguments);
    the :class:`ResolverMatch` object (as well as the namespace and pattern
    information it provides) is not available in earlier Django releases.

One possible use of :func:`~django.core.urlresolvers.resolve` would be to test
whether a view would raise a ``Http404`` error before redirecting to it::

    from urlparse import urlparse
    from django.core.urlresolvers import resolve
    from django.http import HttpResponseRedirect, Http404

    def myview(request):
        next = request.META.get('HTTP_REFERER', None) or '/'
        response = HttpResponseRedirect(next)

        # modify the request and response as required, e.g. change locale
        # and set corresponding locale cookie

        view, args, kwargs = resolve(urlparse(next)[2])
        kwargs['request'] = request
        try:
            view(*args, **kwargs)
        except Http404:
            return HttpResponseRedirect('/')
        return response


permalink()
-----------

The :func:`django.db.models.permalink` decorator is useful for writing short
methods that return a full URL path. For example, a model's
``get_absolute_url()`` method. See :func:`django.db.models.permalink` for more.

get_script_prefix()
-------------------

.. function:: get_script_prefix()

Normally, you should always use :func:`~django.core.urlresolvers.reverse` or
:func:`~django.db.models.permalink` to define URLs within your application.
However, if your application constructs part of the URL hierarchy itself, you
may occasionally need to generate URLs. In that case, you need to be able to
find the base URL of the Django project within its Web server
(normally, :func:`~django.core.urlresolvers.reverse` takes care of this for
you). In that case, you can call ``get_script_prefix()``, which will return the
script prefix portion of the URL for your Django project. If your Django
project is at the root of its Web server, this is always ``"/"``, but it can be
changed, for instance  by using ``django.root`` (see :doc:`How to use
Django with Apache and mod_python </howto/deployment/modpython>`).
